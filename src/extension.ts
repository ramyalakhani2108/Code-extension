// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
import * as vscode from 'vscode';
import { TodoTreeDataProvider, TodoTreeItem } from './todoProvider';

// Helper function to generate log content from current tasks in original format
function generateLogFromCurrentTasks(todos: any[]): string {
	// Start with the original header format
	let logContent = '# Todo Tasks Log\n# Generated by VS Code Todo Task Reminder Extension\n\n';
	
	// Group tasks by date (for current tasks, use today's date)
	const today = new Date();
	const dateStr = today.toLocaleDateString('en-US', {
		weekday: 'long',
		year: 'numeric',
		month: 'long',
		day: 'numeric'
	});
	
	// Group tasks by project
	const tasksByProject: { [key: string]: any[] } = {};
	
	todos.forEach((todo: any) => {
		const projectName = todo.project || 'Other';
		if (!tasksByProject[projectName]) {
			tasksByProject[projectName] = [];
		}
		tasksByProject[projectName].push(todo);
	});
	
	// Add date header
	logContent += `${dateStr}'s tasks:\n\n`;
	
	// Add each project section
	Object.keys(tasksByProject).forEach(projectName => {
		logContent += `#${projectName}\n`;
		
		tasksByProject[projectName].forEach(todo => {
			logContent += `- ${todo.text}\n`;
		});
		
		logContent += '\n';
	});
	
	return logContent;
}

// Helper function to show protected log view
async function showProtectedLogView(content: string, filePath: string, todoProvider: TodoTreeDataProvider) {
	// Create a unique URI for the read-only document
	const uri = vscode.Uri.parse(`untitled:Task Log (Protected View)`);
	
	// Create a new document with the log content
	const document = await vscode.workspace.openTextDocument({
		content: content,
		language: 'plaintext'
	});
	
	// Show the document
	const editor = await vscode.window.showTextDocument(document, {
		preview: false,
		viewColumn: vscode.ViewColumn.Beside
	});
	
	// Show information message with options
	const choice = await vscode.window.showInformationMessage(
		'üìÑ Task Log (Protected View) - This is a safe preview. Your original log is protected from accidental changes.',
		'üìù Edit Original File',
		'üîÑ Regenerate Log',
		'üìã Copy Content',
		'OK'
	);
	
	if (choice === 'üìù Edit Original File') {
		const confirm = await vscode.window.showWarningMessage(
			'‚ö†Ô∏è You are about to edit the original log file. Any changes will be permanent!',
			{ modal: true },
			'Continue',
			'Cancel'
		);
		
		if (confirm === 'Continue') {
			// Close the protected view first
			await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
			
			// Open the actual file for editing
			const originalDocument = await vscode.workspace.openTextDocument(filePath);
			await vscode.window.showTextDocument(originalDocument, {
				preview: false,
				viewColumn: vscode.ViewColumn.Active
			});
			
			vscode.window.showWarningMessage('‚ö†Ô∏è You are now editing the original log file - be careful!');
		}
	} else if (choice === 'üîÑ Regenerate Log') {
		const confirm = await vscode.window.showWarningMessage(
			'üîÑ This will regenerate the log file from current tasks using the original format and overwrite existing log. Continue?',
			{ modal: true },
			'Yes, Regenerate',
			'Cancel'
		);
		
		if (confirm === 'Yes, Regenerate') {
			try {
				const fs = require('fs').promises;
				const allTodos = todoProvider.getAllTodos();
				const newLogContent = generateLogFromCurrentTasks(allTodos);
				
				await fs.writeFile(filePath, newLogContent, 'utf8');
				
				// Close current view and show new protected view
				await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
				await showProtectedLogView(newLogContent, filePath, todoProvider);
				
				vscode.window.showInformationMessage('‚úÖ Task log regenerated successfully!');
			} catch (error) {
				vscode.window.showErrorMessage(`Failed to regenerate log: ${error}`);
			}
		}
	} else if (choice === 'üìã Copy Content') {
		await vscode.env.clipboard.writeText(content);
		vscode.window.showInformationMessage('üìã Log content copied to clipboard!');
	}
}

// Helper function for user-friendly reminder picker
async function showSmartReminderPicker(): Promise<Date | undefined> {
	const now = new Date();
	
	// Smart quick options with context
	const quickOptions = [
		{ label: '‚ö° In 5 minutes', description: 'Quick reminder', value: 5 * 60 * 1000 },
		{ label: '‚è∞ In 15 minutes', description: 'Short break reminder', value: 15 * 60 * 1000 },
		{ label: '‚òï In 30 minutes', description: 'Coffee break reminder', value: 30 * 60 * 1000 },
		{ label: 'üïê In 1 hour', description: 'Hourly reminder', value: 60 * 60 * 1000 },
		{ label: 'üïï In 2 hours', description: 'Extended reminder', value: 2 * 60 * 60 * 1000 },
		{ label: 'üåÖ Tomorrow at 9 AM', description: 'Start of workday', value: 'tomorrow9am' },
		{ label: 'üìÖ Choose specific date', description: 'Custom date and time', value: 'custom' },
		{ label: 'üéØ Smart suggestions', description: 'AI-powered suggestions', value: 'smart' }
	];

	const selected = await vscode.window.showQuickPick(quickOptions, {
		placeHolder: '‚è∞ When should I remind you about this todo?',
		matchOnDescription: true,
		ignoreFocusOut: true
	});

	if (!selected) {
		return undefined;
	}

	// Handle quick time options
	if (typeof selected.value === 'number') {
		return new Date(now.getTime() + selected.value);
	}

	// Handle tomorrow 9 AM
	if (selected.value === 'tomorrow9am') {
		const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 9, 0);
		return tomorrow;
	}

	// Handle smart suggestions
	if (selected.value === 'smart') {
		return await showSmartSuggestions();
	}

	// Handle custom date/time picker
	if (selected.value === 'custom') {
		return await showAdvancedDateTimePicker();
	}

	return undefined;
}

// Smart suggestions based on context
async function showSmartSuggestions(): Promise<Date | undefined> {
	const now = new Date();
	const currentHour = now.getHours();
	
	const suggestions = [];
	
	// Morning suggestions (6 AM - 12 PM)
	if (currentHour >= 6 && currentHour < 12) {
		suggestions.push(
			{ label: 'üåÖ End of morning (12 PM)', date: new Date(now.getFullYear(), now.getMonth(), now.getDate(), 12, 0) },
			{ label: 'üçΩÔ∏è Lunch time (1 PM)', date: new Date(now.getFullYear(), now.getMonth(), now.getDate(), 13, 0) },
			{ label: 'üåÜ End of workday (5 PM)', date: new Date(now.getFullYear(), now.getMonth(), now.getDate(), 17, 0) }
		);
	}
	// Afternoon suggestions (12 PM - 6 PM)
	else if (currentHour >= 12 && currentHour < 18) {
		suggestions.push(
			{ label: 'üåÜ End of workday (5 PM)', date: new Date(now.getFullYear(), now.getMonth(), now.getDate(), 17, 0) },
			{ label: 'üåô Evening (7 PM)', date: new Date(now.getFullYear(), now.getMonth(), now.getDate(), 19, 0) },
			{ label: 'üåÖ Tomorrow morning (9 AM)', date: new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 9, 0) }
		);
	}
	// Evening/Night suggestions (6 PM - 6 AM)
	else {
		suggestions.push(
			{ label: 'üåÖ Tomorrow morning (9 AM)', date: new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 9, 0) },
			{ label: 'üçΩÔ∏è Tomorrow lunch (1 PM)', date: new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 13, 0) },
			{ label: 'üåÜ Tomorrow evening (5 PM)', date: new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 17, 0) }
		);
	}

	// Add weekend suggestions if it's a weekday
	const dayOfWeek = now.getDay();
	if (dayOfWeek >= 1 && dayOfWeek <= 5) {
		const daysUntilWeekend = 6 - dayOfWeek; // Saturday
		suggestions.push({
			label: 'üéÆ This weekend (Saturday 10 AM)',
			date: new Date(now.getFullYear(), now.getMonth(), now.getDate() + daysUntilWeekend, 10, 0)
		});
	}

	const selected = await vscode.window.showQuickPick(
		suggestions.map(s => ({
			label: s.label,
			description: s.date.toLocaleString(),
			date: s.date
		})),
		{
			placeHolder: 'üéØ Choose a smart reminder time',
			ignoreFocusOut: true
		}
	);

	return selected?.date;
}

// Custom date/time picker with step-by-step UX
async function showCustomDateTimePicker(): Promise<Date | undefined> {
	// Step 1: Choose date
	const dateOptions = [
		{ label: 'üìÖ Today', value: 'today' },
		{ label: 'üìÖ Tomorrow', value: 'tomorrow' },
		{ label: 'üìÖ Day after tomorrow', value: 'dayafter' },
		{ label: 'üìÖ This weekend (Saturday)', value: 'weekend' },
		{ label: 'üìÖ Next week (Monday)', value: 'nextweek' },
		{ label: 'üìù Type specific date', value: 'custom' }
	];

	const selectedDate = await vscode.window.showQuickPick(dateOptions, {
		placeHolder: 'üìÖ Step 1/2: Choose the date',
		ignoreFocusOut: true
	});

	if (!selectedDate) {
		return undefined;
	}

	let targetDate: Date;
	const now = new Date();

	switch (selectedDate.value) {
		case 'today':
			targetDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
			break;
		case 'tomorrow':
			targetDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
			break;
		case 'dayafter':
			targetDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 2);
			break;
		case 'weekend':
			const daysUntilSaturday = 6 - now.getDay();
			targetDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + daysUntilSaturday);
			break;
		case 'nextweek':
			const daysUntilNextMonday = 8 - now.getDay();
			targetDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + daysUntilNextMonday);
			break;
		case 'custom':
			const dateInput = await vscode.window.showInputBox({
				placeHolder: 'YYYY-MM-DD (e.g., 2025-12-25)',
				prompt: 'üìÖ Enter date in YYYY-MM-DD format',
				validateInput: (value) => {
					const date = new Date(value);
					if (isNaN(date.getTime())) {
						return 'Invalid date format. Use YYYY-MM-DD';
					}
					if (date < new Date(now.getFullYear(), now.getMonth(), now.getDate())) {
						return 'Date cannot be in the past';
					}
					return null;
				}
			});
			if (!dateInput) {
				return undefined;
			}
			targetDate = new Date(dateInput);
			break;
		default:
			return undefined;
	}

	// Step 2: Choose time
	const timeOptions = [
		{ label: 'üåÖ Morning (9:00 AM)', hour: 9, minute: 0 },
		{ label: '‚òï Mid-morning (10:30 AM)', hour: 10, minute: 30 },
		{ label: 'üåû Noon (12:00 PM)', hour: 12, minute: 0 },
		{ label: 'üçΩÔ∏è Lunch (1:00 PM)', hour: 13, minute: 0 },
		{ label: '‚òï Afternoon (3:00 PM)', hour: 15, minute: 0 },
		{ label: 'üåÜ End of workday (5:00 PM)', hour: 17, minute: 0 },
		{ label: 'üåô Evening (7:00 PM)', hour: 19, minute: 0 },
		{ label: '‚è∞ Custom time', hour: -1, minute: -1 }
	];

	const selectedTime = await vscode.window.showQuickPick(timeOptions, {
		placeHolder: '‚è∞ Step 2/2: Choose the time',
		ignoreFocusOut: true
	});

	if (!selectedTime) {
		return undefined;
	}

	let finalDateTime: Date;

	if (selectedTime.hour === -1) {
		// Custom time input
		const timeInput = await vscode.window.showInputBox({
			placeHolder: 'HH:MM (e.g., 14:30 for 2:30 PM)',
			prompt: '‚è∞ Enter time in 24-hour format (HH:MM)',
			validateInput: (value) => {
				const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
				if (!timeRegex.test(value)) {
					return 'Invalid time format. Use HH:MM (24-hour format)';
				}
				return null;
			}
		});
		if (!timeInput) {
			return undefined;
		}
		const [hour, minute] = timeInput.split(':').map(Number);
		finalDateTime = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate(), hour, minute);
	} else {
		finalDateTime = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate(), selectedTime.hour, selectedTime.minute);
	}

	// Validate that the time is in the future
	if (finalDateTime <= now) {
		vscode.window.showErrorMessage('‚ö†Ô∏è Reminder time must be in the future!');
		return undefined;
	}

	return finalDateTime;
}

// Advanced date/time picker with calendar-like interface
async function showAdvancedDateTimePicker(): Promise<Date | undefined> {
	// First, show a more intuitive date picker
	const dateInput = await vscode.window.showInputBox({
		placeHolder: 'YYYY-MM-DD (e.g., 2025-12-31) or use shortcuts like "today", "tomorrow", "monday"',
		prompt: 'üìÖ Enter a date or use natural language',
		ignoreFocusOut: true,
		validateInput: (value) => {
			if (!value) return 'Please enter a date';
			
			const input = value.trim().toLowerCase();
			
			// Handle natural language shortcuts
			if (['today', 'tomorrow', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'].includes(input)) {
				return null;
			}
			
			// Handle relative dates
			if (input.match(/^(next|this)\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)$/)) {
				return null;
			}
			
			// Handle "in X days" format
			if (input.match(/^in\s+\d+\s+days?$/)) {
				return null;
			}
			
			// Validate standard date format
			const date = new Date(value);
			if (isNaN(date.getTime())) {
				return 'Invalid date format. Use YYYY-MM-DD or natural language like "tomorrow", "next friday"';
			}
			
			const now = new Date();
			if (date < new Date(now.getFullYear(), now.getMonth(), now.getDate())) {
				return 'Date cannot be in the past';
			}
			
			return null;
		}
	});

	if (!dateInput) {
		return undefined;
	}

	// Parse the date input
	const targetDate = parseNaturalDate(dateInput.trim());
	if (!targetDate) {
		vscode.window.showErrorMessage('Could not parse the date. Please try again.');
		return undefined;
	}

	// Now show an enhanced time picker
	const timeOptions = [
		{ label: 'üåÖ 6:00 AM - Early morning', time: '06:00' },
		{ label: '‚òï 8:00 AM - Morning coffee', time: '08:00' },
		{ label: 'üåÖ 9:00 AM - Start of workday', time: '09:00' },
		{ label: '‚òï 10:30 AM - Mid-morning break', time: '10:30' },
		{ label: 'üåû 12:00 PM - Lunch time', time: '12:00' },
		{ label: 'üçΩÔ∏è 1:00 PM - After lunch', time: '13:00' },
		{ label: '‚òï 3:00 PM - Afternoon break', time: '15:00' },
		{ label: 'üè¢ 5:00 PM - End of workday', time: '17:00' },
		{ label: 'üåÜ 6:00 PM - Evening', time: '18:00' },
		{ label: 'üçΩÔ∏è 7:00 PM - Dinner time', time: '19:00' },
		{ label: 'üåô 9:00 PM - Night', time: '21:00' },
		{ label: 'üõèÔ∏è 11:00 PM - Before bed', time: '23:00' },
		{ label: '‚è∞ Custom time', time: 'custom' }
	];

	const selectedTime = await vscode.window.showQuickPick(timeOptions, {
		placeHolder: `‚è∞ Choose time for ${targetDate.toLocaleDateString()}`,
		ignoreFocusOut: true,
		matchOnDescription: true
	});

	if (!selectedTime) {
		return undefined;
	}

	let finalTime = selectedTime.time;

	if (selectedTime.time === 'custom') {
		const customTime = await vscode.window.showInputBox({
			placeHolder: '14:30 (for 2:30 PM), 09:15 (for 9:15 AM), etc.',
			prompt: '‚è∞ Enter time in HH:MM format (24-hour)',
			ignoreFocusOut: true,
			validateInput: (value) => {
				if (!value) return 'Please enter a time';
				const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
				if (!timeRegex.test(value)) {
					return 'Invalid time format. Use HH:MM (24-hour format). Examples: 09:30, 14:15, 23:45';
				}
				return null;
			}
		});
		
		if (!customTime) {
			return undefined;
		}
		
		finalTime = customTime;
	}

	// Combine date and time
	const [hour, minute] = finalTime.split(':').map(Number);
	const finalDateTime = new Date(
		targetDate.getFullYear(),
		targetDate.getMonth(),
		targetDate.getDate(),
		hour,
		minute,
		0,
		0
	);

	// Final validation
	const now = new Date();
	if (finalDateTime <= now) {
		vscode.window.showErrorMessage('‚ö†Ô∏è The selected date and time must be in the future!');
		return undefined;
	}

	return finalDateTime;
}

// Parse natural language dates
function parseNaturalDate(input: string): Date | null {
	const now = new Date();
	const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
	
	const lower = input.toLowerCase().trim();
	
	switch (lower) {
		case 'today':
			return today;
		case 'tomorrow':
			return new Date(today.getTime() + 24 * 60 * 60 * 1000);
		case 'monday':
		case 'tuesday':
		case 'wednesday':
		case 'thursday':
		case 'friday':
		case 'saturday':
		case 'sunday':
			return getNextWeekday(lower);
		default:
			break;
	}
	
	// Handle "next [weekday]" or "this [weekday]"
	const weekdayMatch = lower.match(/^(next|this)\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)$/);
	if (weekdayMatch) {
		const [, modifier, weekday] = weekdayMatch;
		const targetDate = getNextWeekday(weekday);
		if (modifier === 'next') {
			targetDate.setDate(targetDate.getDate() + 7);
		}
		return targetDate;
	}
	
	// Handle "in X days"
	const daysMatch = lower.match(/^in\s+(\d+)\s+days?$/);
	if (daysMatch) {
		const days = parseInt(daysMatch[1]);
		return new Date(today.getTime() + days * 24 * 60 * 60 * 1000);
	}
	
	// Try to parse as standard date
	const date = new Date(input);
	if (!isNaN(date.getTime())) {
		return date;
	}
	
	return null;
}

// Get next occurrence of a weekday
function getNextWeekday(weekdayName: string): Date {
	const weekdays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
	const targetDay = weekdays.indexOf(weekdayName.toLowerCase());
	
	const now = new Date();
	const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
	const currentDay = today.getDay();
	
	let daysUntilTarget = targetDay - currentDay;
	if (daysUntilTarget <= 0) {
		daysUntilTarget += 7; // Next week
	}
	
	return new Date(today.getTime() + daysUntilTarget * 24 * 60 * 60 * 1000);
}

// Format reminder time for user-friendly display
function formatReminderTime(date: Date): string {
	const now = new Date();
	const diffMs = date.getTime() - now.getTime();
	const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
	const diffMinutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));

	// If it's today
	if (date.toDateString() === now.toDateString()) {
		if (diffHours === 0) {
			return `in ${diffMinutes} minute${diffMinutes !== 1 ? 's' : ''} (${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})})`;
		} else if (diffHours < 24) {
			return `in ${diffHours} hour${diffHours !== 1 ? 's' : ''} (${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})})`;
		}
	}

	// If it's tomorrow
	const tomorrow = new Date(now);
	tomorrow.setDate(tomorrow.getDate() + 1);
	if (date.toDateString() === tomorrow.toDateString()) {
		return `tomorrow at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
	}

	// For other dates
	return date.toLocaleString([], {
		weekday: 'short',
		month: 'short',
		day: 'numeric',
		hour: '2-digit',
		minute: '2-digit'
	});
}

// Format date for display
function formatDate(date: Date): string {
	const now = new Date();
	const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
	const tomorrow = new Date(today);
	tomorrow.setDate(tomorrow.getDate() + 1);
	
	const targetDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
	
	if (targetDate.getTime() === today.getTime()) {
		return 'today';
	} else if (targetDate.getTime() === tomorrow.getTime()) {
		return 'tomorrow';
	} else {
		const diffDays = Math.ceil((targetDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
		if (diffDays > 0 && diffDays <= 7) {
			return `in ${diffDays} day${diffDays !== 1 ? 's' : ''}`;
		}
		return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
	}
}

// Enhanced todo creator with better UX flow
interface TodoCreatorResult {
	text: string;
	priority: 'low' | 'medium' | 'high';
	dueDate?: Date;
	projectName?: string;
}

async function showEnhancedTodoCreator(): Promise<TodoCreatorResult | undefined> {
	// Step 1: Get todo text with better prompts
	const text = await vscode.window.showInputBox({
		placeHolder: 'What do you need to do? (e.g., "Review pull request", "Call team meeting")',
		prompt: 'üìù Step 1/3: Describe your todo',
		ignoreFocusOut: true,
		validateInput: (value) => {
			if (!value || value.trim().length === 0) {
				return 'Todo text cannot be empty';
			}
			if (value.trim().length > 200) {
				return 'Todo text is too long (max 200 characters)';
			}
			return null;
		}
	});

	if (!text || !text.trim()) {
		return undefined;
	}

	// Step 2: Choose priority with visual indicators
	const priorityOptions = [
		{ 
			label: 'üü¢ Low Priority', 
			description: 'No rush, can be done later',
			detail: 'For tasks that are nice to have but not urgent',
			value: 'low' as const
		},
		{ 
			label: 'üü° Medium Priority', 
			description: 'Normal priority, should be done soon',
			detail: 'For regular tasks that need attention',
			value: 'medium' as const
		},
		{ 
			label: 'üî¥ High Priority', 
			description: 'Urgent, needs immediate attention',
			detail: 'For critical tasks that cannot wait',
			value: 'high' as const
		}
	];

	const selectedPriority = await vscode.window.showQuickPick(priorityOptions, {
		placeHolder: '‚ö° Step 2/3: How urgent is this todo?',
		ignoreFocusOut: true,
		matchOnDescription: true,
		matchOnDetail: true
	});

	if (!selectedPriority) {
		return undefined;
	}

	// Step 3: Choose due date with smart options
	const dueDateOptions = [
		{ label: 'üìÖ No due date', description: 'Complete whenever convenient', value: 'none' },
		{ label: 'üïê Today', description: 'Due by end of today', value: 'today' },
		{ label: 'üìÖ Tomorrow', description: 'Due by end of tomorrow', value: 'tomorrow' },
		{ label: 'üìÖ This week', description: 'Due by end of this week', value: 'week' },
		{ label: 'üìÖ Next week', description: 'Due by end of next week', value: 'nextweek' },
		{ label: 'üìù Choose specific date', description: 'Custom due date', value: 'custom' }
	];

	const selectedDueDate = await vscode.window.showQuickPick(dueDateOptions, {
		placeHolder: 'üìÖ Step 3/3: When should this be completed?',
		ignoreFocusOut: true,
		matchOnDescription: true
	});

	if (!selectedDueDate) {
		return undefined;
	}

	let dueDate: Date | undefined;
	const now = new Date();

	switch (selectedDueDate.value) {
		case 'none':
			dueDate = undefined;
			break;
		case 'today':
			dueDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59);
			break;
		case 'tomorrow':
			dueDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 23, 59);
			break;
		case 'week':
			const daysUntilSunday = 7 - now.getDay();
			dueDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + daysUntilSunday, 23, 59);
			break;
		case 'nextweek':
			const daysUntilNextSunday = 14 - now.getDay();
			dueDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + daysUntilNextSunday, 23, 59);
			break;
		case 'custom':
			const customDate = await showAdvancedDateTimePicker();
			dueDate = customDate;
			break;
	}

	// Step 4: Choose project (NEW!)
	const projectOptions = [
		{ label: 'üìÅ No Project', description: 'General task not tied to a specific project', value: undefined },
		{ label: 'üíº Work', description: 'Work-related tasks', value: 'Work' },
		{ label: 'üè† Personal', description: 'Personal life tasks', value: 'Personal' },
		{ label: 'üíª Development', description: 'Coding and development tasks', value: 'Development' },
		{ label: 'üìö Learning', description: 'Education and skill development', value: 'Learning' },
		{ label: 'üè• Health', description: 'Health and fitness related tasks', value: 'Health' },
		{ label: 'üí∞ Finance', description: 'Financial and budgeting tasks', value: 'Finance' },
		{ label: 'üé® Creative', description: 'Creative projects and hobbies', value: 'Creative' },
		{ label: '‚úèÔ∏è Custom Project', description: 'Create a new project category', value: 'custom' }
	];

	const selectedProject = await vscode.window.showQuickPick(projectOptions, {
		placeHolder: 'üìÅ Step 4/4: Choose a project category (optional)',
		ignoreFocusOut: true,
		matchOnDescription: true
	});

	if (!selectedProject) {
		return undefined;
	}

	let projectName = selectedProject.value;

	// Handle custom project creation
	if (selectedProject.value === 'custom') {
		const customProject = await vscode.window.showInputBox({
			placeHolder: 'Enter project name (e.g., "Mobile App", "Website Redesign")',
			prompt: 'üìÅ Create new project category',
			ignoreFocusOut: true,
			validateInput: (value) => {
				if (!value || value.trim().length === 0) {
					return 'Project name cannot be empty';
				}
				if (value.trim().length > 50) {
					return 'Project name is too long (max 50 characters)';
				}
				return null;
			}
		});
		
		if (!customProject) {
			return undefined;
		}
		
		projectName = customProject.trim();
	}

	return {
		text: text.trim(),
		priority: selectedPriority.value,
		dueDate,
		projectName
	};
}

// Complete task editor for all properties
async function showCompleteTaskEditor(todo: any): Promise<any | undefined> {
	// Step 1: Choose what to edit
	const editOptions = [
		{ label: 'üìù Edit Task Text', description: `Current: "${todo.text}"`, value: 'text' },
		{ label: '‚≠ê Edit Priority', description: `Current: ${todo.priority === 'high' ? 'üî¥' : todo.priority === 'medium' ? 'üü°' : 'üü¢'} ${todo.priority}`, value: 'priority' },
		{ label: 'üìÅ Edit Project', description: `Current: ${todo.projectName || 'Other'}`, value: 'project' },
		{ label: 'üìÖ Edit Due Date', description: todo.dueDate ? `Current: ${new Date(todo.dueDate).toLocaleDateString()}` : 'No due date set', value: 'dueDate' },
		{ label: 'üîß Edit All Properties', description: 'Comprehensive editing workflow', value: 'all' },
		{ label: '‚ùå Cancel', description: 'No changes', value: 'cancel' }
	];

	const editChoice = await vscode.window.showQuickPick(editOptions, {
		placeHolder: '‚úèÔ∏è What would you like to edit?',
		ignoreFocusOut: true
	});

	if (!editChoice || editChoice.value === 'cancel') {
		return undefined;
	}

	// Create result object with current values
	const result = {
		text: todo.text,
		priority: todo.priority,
		projectName: todo.projectName,
		dueDate: todo.dueDate
	};

	// Handle specific property editing
	if (editChoice.value === 'text' || editChoice.value === 'all') {
		const newText = await vscode.window.showInputBox({
			value: result.text,
			prompt: 'üìù Edit task description',
			placeHolder: 'Enter task description...',
			ignoreFocusOut: true,
			validateInput: (value) => {
				if (!value || value.trim().length === 0) {
					return 'Task text cannot be empty';
				}
				if (value.trim().length > 200) {
					return 'Task text is too long (max 200 characters)';
				}
				return null;
			}
		});
		
		if (newText === undefined) return undefined; // User cancelled
		result.text = newText.trim();
	}

	if (editChoice.value === 'priority' || editChoice.value === 'all') {
		const priorityOptions = [
			{ label: 'üî¥ High Priority', description: 'Urgent and important tasks', value: 'high' },
			{ label: 'üü° Medium Priority', description: 'Important but not urgent', value: 'medium' },
			{ label: 'üü¢ Low Priority', description: 'Nice to have tasks', value: 'low' }
		];

		const priorityChoice = await vscode.window.showQuickPick(priorityOptions, {
			placeHolder: `‚≠ê Select priority (Current: ${result.priority})`,
			ignoreFocusOut: true
		});

		if (priorityChoice === undefined) return undefined; // User cancelled
		result.priority = priorityChoice.value as 'high' | 'medium' | 'low';
	}

	if (editChoice.value === 'project' || editChoice.value === 'all') {
		const newProject = await vscode.window.showInputBox({
			value: result.projectName || '',
			prompt: 'üìÅ Edit project name (leave empty for "Other")',
			placeHolder: 'Enter project name...',
			ignoreFocusOut: true
		});
		
		if (newProject === undefined) return undefined; // User cancelled
		result.projectName = newProject.trim() || 'Other';
	}

	if (editChoice.value === 'dueDate' || editChoice.value === 'all') {
		const dueDateChoice = await vscode.window.showQuickPick([
			{ label: 'üìÖ Set Due Date', description: 'Choose a specific date', value: 'set' },
			{ label: 'üóëÔ∏è Remove Due Date', description: 'Clear existing due date', value: 'remove' },
			{ label: '‚è≠Ô∏è Skip', description: 'Keep current due date', value: 'skip' }
		], {
			placeHolder: 'üìÖ Due date options',
			ignoreFocusOut: true
		});

		if (dueDateChoice === undefined) return undefined; // User cancelled

		if (dueDateChoice.value === 'set') {
			const dateResult = await showAdvancedDateTimePicker();
			if (dateResult === undefined) return undefined; // User cancelled
			result.dueDate = dateResult;
		} else if (dueDateChoice.value === 'remove') {
			result.dueDate = undefined;
		}
		// 'skip' keeps the current value
	}

	return result;
}

// Task selector for bulk operations
async function showTaskSelector(todos: any[], operation: string): Promise<any[]> {
	if (todos.length === 0) return [];

	// Create multi-select options
	const taskOptions = todos.map(todo => ({
		label: `${todo.completed ? '‚úÖ' : '‚è≥'} ${todo.text}`,
		description: `${todo.priority === 'high' ? 'üî¥' : todo.priority === 'medium' ? 'üü°' : 'üü¢'} ${todo.projectName || 'Other'}`,
		picked: false,
		task: todo
	}));

	const selectedOptions = await vscode.window.showQuickPick(taskOptions, {
		placeHolder: `Select tasks to ${operation.toLowerCase()}`,
		canPickMany: true,
		ignoreFocusOut: true
	});

	return selectedOptions ? selectedOptions.map(option => option.task) : [];
}

// Select tasks by project
async function selectTasksByProject(todos: any[]): Promise<any[]> {
	const projects = new Set<string>();
	todos.forEach(todo => projects.add(todo.projectName || 'Other'));
	
	const projectOptions = Array.from(projects).map(project => ({
		label: `üìÅ ${project}`,
		description: `${todos.filter(t => (t.projectName || 'Other') === project).length} tasks`,
		value: project
	}));

	const selectedProject = await vscode.window.showQuickPick(projectOptions, {
		placeHolder: 'Select project to delete all tasks from',
		ignoreFocusOut: true
	});

	if (!selectedProject) return [];
	
	return todos.filter(todo => (todo.projectName || 'Other') === selectedProject.value);
}

// Select tasks by priority
async function selectTasksByPriority(todos: any[]): Promise<any[]> {
	const priorityOptions = [
		{ label: 'üî¥ High Priority', description: `${todos.filter(t => t.priority === 'high').length} tasks`, value: 'high' },
		{ label: 'üü° Medium Priority', description: `${todos.filter(t => t.priority === 'medium').length} tasks`, value: 'medium' },
		{ label: 'üü¢ Low Priority', description: `${todos.filter(t => t.priority === 'low').length} tasks`, value: 'low' }
	];

	const selectedPriority = await vscode.window.showQuickPick(priorityOptions, {
		placeHolder: 'Select priority level to delete all tasks from',
		ignoreFocusOut: true
	});

	if (!selectedPriority) return [];
	
	return todos.filter(todo => todo.priority === selectedPriority.value);
}

// Custom filter builder for advanced filtering
async function showCustomFilterBuilder(todoProvider: any): Promise<void> {
	const customFilter: any = {};

	// Step 1: Status filter
	const statusOptions = [
		{ label: 'üìã All Status', value: null },
		{ label: '‚è≥ Pending Only', value: 'pending' },
		{ label: '‚úÖ Completed Only', value: 'completed' },
		{ label: '‚ö†Ô∏è Overdue Only', value: 'overdue' },
		{ label: 'üìã Pending + Overdue', value: 'pending+overdue' }
	];

	const statusChoice = await vscode.window.showQuickPick(statusOptions, {
		placeHolder: 'üéØ Filter by Status',
		ignoreFocusOut: true
	});
	if (!statusChoice) return;
	
	if (statusChoice.value === 'pending+overdue') {
		customFilter.status = ['pending', 'overdue'];
	} else if (statusChoice.value && statusChoice.value !== null) {
		customFilter.status = [statusChoice.value];
	}

	// Step 2: Priority filter  
	const priorityOptions = [
		{ label: 'üéØ All Priorities', value: null },
		{ label: 'ÔøΩ High Priority Only', value: 'high' },
		{ label: 'ÔøΩ Medium Priority Only', value: 'medium' },
		{ label: '‚ö™ Low Priority Only', value: 'low' },
		{ label: 'ÔøΩ High + Medium', value: 'high+medium' }
	];

	const priorityChoice = await vscode.window.showQuickPick(priorityOptions, {
		placeHolder: '‚≠ê Filter by Priority',
		ignoreFocusOut: true
	});
	if (!priorityChoice) return;
	
	if (priorityChoice.value === 'high+medium') {
		customFilter.priority = ['high', 'medium'];
	} else if (priorityChoice.value && priorityChoice.value !== null) {
		customFilter.priority = [priorityChoice.value];
	}

	// Step 3: Date range filter
	const dateOptions = [
		{ label: 'üìÖ All Dates', value: 'all' },
		{ label: 'üìÖ Today', value: 'today' },
		{ label: 'üìÖ This Week', value: 'thisWeek' },
		{ label: 'üìÖ This Month', value: 'thisMonth' },
		{ label: '‚ö†Ô∏è Overdue', value: 'overdue' },
		{ label: 'üîÆ Upcoming', value: 'upcoming' }
	];

	const dateChoice = await vscode.window.showQuickPick(dateOptions, {
		placeHolder: 'üìÖ Filter by Date Range',
		ignoreFocusOut: true
	});
	if (!dateChoice) return;
	if (dateChoice.value && dateChoice.value !== 'all') {
		customFilter.dateRange = dateChoice.value;
	}

	// Step 4: Project filter (dynamic based on available projects)
	const availableProjects = todoProvider.getAvailableProjects();
	if (availableProjects.length > 1) {
		const projectOptions = [
			{ label: 'üìÅ All Projects', value: null },
			...availableProjects.map((project: string) => ({
				label: `üìÅ ${project}`,
				value: project
			}))
		];

		const projectChoice = await vscode.window.showQuickPick(projectOptions, {
			placeHolder: 'üìÅ Filter by Project',
			ignoreFocusOut: true
		});
		if (!projectChoice) return;
		if (projectChoice.value && projectChoice.value !== null) {
			customFilter.projects = [projectChoice.value];
		}
	}

	// Step 5: Optional search text
	const searchText = await vscode.window.showInputBox({
		prompt: 'üîç Search in task text (optional)',
		placeHolder: 'Enter keywords to search for...',
		ignoreFocusOut: true
	});
	if (searchText && searchText.trim()) {
		customFilter.searchText = searchText.trim();
	}

	// Apply the custom filter
	todoProvider.setFilter(customFilter);

	// Show confirmation
	const filterDescription = [];
	if (customFilter.status) filterDescription.push(`Status: ${customFilter.status.join(', ')}`);
	if (customFilter.priority) filterDescription.push(`Priority: ${customFilter.priority.join(', ')}`);
	if (customFilter.dateRange) filterDescription.push(`Date: ${customFilter.dateRange}`);
	if (customFilter.projects) filterDescription.push(`Project: ${customFilter.projects.join(', ')}`);
	if (customFilter.searchText) filterDescription.push(`Search: "${customFilter.searchText}"`);

	const description = filterDescription.length > 0 ? filterDescription.join(' ‚Ä¢ ') : 'No filters';
	vscode.window.showInformationMessage(`üîç Custom filter applied: ${description}`);
}

// Generate beautiful HTML for task detail view
function generateTaskDetailHTML(todo: any): string {
	const now = new Date();
	const isOverdue = todo.dueDate && new Date(todo.dueDate) < now && !todo.completed;
	const priorityColor = todo.priority === 'high' ? '#ff4757' : 
						  todo.priority === 'medium' ? '#ffa502' : '#57606f';
	const statusIcon = todo.completed ? '‚úÖ' : (isOverdue ? '‚ö†Ô∏è' : '‚è≥');
	const statusText = todo.completed ? 'Completed' : (isOverdue ? 'Overdue' : 'Active');
	const statusColor = todo.completed ? '#2ed573' : (isOverdue ? '#ff4757' : '#3742fa');

	return `
		<!DOCTYPE html>
		<html lang="en">
		<head>
			<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1.0">
			<title>Task Details</title>
			<style>
				body {
					font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
					margin: 0;
					padding: 20px;
					background: var(--vscode-editor-background);
					color: var(--vscode-editor-foreground);
					line-height: 1.6;
				}
				.task-header {
					background: var(--vscode-sideBar-background);
					border-radius: 8px;
					padding: 20px;
					margin-bottom: 20px;
					border-left: 4px solid ${priorityColor};
				}
				.task-title {
					font-size: 1.4em;
					font-weight: 600;
					margin: 0 0 10px 0;
					color: var(--vscode-editor-foreground);
				}
				.task-meta {
					display: flex;
					gap: 15px;
					flex-wrap: wrap;
					margin-top: 15px;
				}
				.meta-item {
					display: flex;
					align-items: center;
					gap: 5px;
					background: var(--vscode-input-background);
					padding: 5px 10px;
					border-radius: 15px;
					font-size: 0.9em;
				}
				.status-badge {
					background: ${statusColor}20;
					color: ${statusColor};
					font-weight: 500;
				}
				.priority-badge {
					background: ${priorityColor}20;
					color: ${priorityColor};
					font-weight: 500;
				}
				.actions {
					display: grid;
					grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
					gap: 10px;
					margin-top: 20px;
				}
				.btn {
					padding: 10px 15px;
					border: none;
					border-radius: 6px;
					cursor: pointer;
					font-weight: 500;
					transition: all 0.2s;
					display: flex;
					align-items: center;
					justify-content: center;
					gap: 6px;
				}
				.btn-primary {
					background: var(--vscode-button-background);
					color: var(--vscode-button-foreground);
				}
				.btn-primary:hover {
					background: var(--vscode-button-hoverBackground);
				}
				.btn-secondary {
					background: var(--vscode-input-background);
					color: var(--vscode-input-foreground);
					border: 1px solid var(--vscode-input-border);
				}
				.btn-danger {
					background: #ff475720;
					color: #ff4757;
					border: 1px solid #ff475740;
				}
				.info-section {
					background: var(--vscode-sideBar-background);
					border-radius: 8px;
					padding: 15px;
					margin-top: 15px;
				}
				.info-title {
					font-weight: 600;
					margin-bottom: 10px;
					color: var(--vscode-editor-foreground);
				}
				.info-item {
					margin: 8px 0;
					display: flex;
					align-items: center;
					gap: 8px;
				}
				.emoji {
					font-size: 1.1em;
				}
			</style>
		</head>
		<body>
			<div class="task-header">
				<div class="task-title">${todo.text}</div>
				<div class="task-meta">
					<div class="meta-item status-badge">
						<span class="emoji">${statusIcon}</span>
						${statusText}
					</div>
					<div class="meta-item priority-badge">
						<span class="emoji">${todo.priority === 'high' ? 'üî¥' : todo.priority === 'medium' ? 'üü°' : '‚ö™'}</span>
						${todo.priority.toUpperCase()} Priority
					</div>
					${todo.projectName ? `<div class="meta-item"><span class="emoji">üìÅ</span>${todo.projectName}</div>` : ''}
				</div>
			</div>

			<div class="actions">
				${!todo.completed ? '<button class="btn btn-primary" onclick="completeTask()">‚úÖ Mark Complete</button>' : '<button class="btn btn-secondary" onclick="completeTask()">‚Ü©Ô∏è Mark Incomplete</button>'}
				<button class="btn btn-secondary" onclick="editTask()">‚úèÔ∏è Edit Text & Priority</button>
				<button class="btn btn-secondary" onclick="setReminder()">üîî Set Reminder</button>
				<button class="btn btn-danger" onclick="deleteTask()">üóëÔ∏è Delete</button>
			</div>

			<div class="info-section">
				<div class="info-title">üìä Task Information</div>
				<div class="info-item">
					<span class="emoji">üìÖ</span>
					<strong>Created:</strong> ${new Date(todo.createdAt).toLocaleDateString()} at ${new Date(todo.createdAt).toLocaleTimeString()}
				</div>
				${todo.dueDate ? `<div class="info-item">
					<span class="emoji">üóìÔ∏è</span>
					<strong>Due Date:</strong> ${new Date(todo.dueDate).toLocaleDateString()} at ${new Date(todo.dueDate).toLocaleTimeString()}
					${isOverdue ? '<span style="color: #ff4757; font-weight: bold;"> (OVERDUE!)</span>' : ''}
				</div>` : ''}
				${todo.reminder ? `<div class="info-item">
					<span class="emoji">üîî</span>
					<strong>Reminder:</strong> ${new Date(todo.reminder).toLocaleDateString()} at ${new Date(todo.reminder).toLocaleTimeString()}
				</div>` : ''}
				<div class="info-item">
					<span class="emoji">üÜî</span>
					<strong>Task ID:</strong> ${todo.id}
				</div>
			</div>

			<div class="info-section">
				<div class="info-title">üéØ Quick Actions</div>
				<div style="display: flex; gap: 10px; flex-wrap: wrap;">
					<button class="btn btn-secondary" onclick="openTaskLog()">üìÑ View Task Log</button>
				</div>
			</div>

			<script>
				const vscode = acquireVsCodeApi();

				function completeTask() {
					vscode.postMessage({ command: 'complete' });
				}

				function editTask() {
					vscode.postMessage({ command: 'edit' });
				}

				function deleteTask() {
					vscode.postMessage({ command: 'delete' });
				}

				function setReminder() {
					vscode.postMessage({ command: 'setReminder' });
				}

				function openTaskLog() {
					vscode.postMessage({ command: 'openLog' });
				}
			</script>
		</body>
		</html>
	`;
}

// Global panel management for single tab functionality
let activeTaskDetailPanels: Map<string, vscode.WebviewPanel> = new Map();

// This method is called when your extension is activated
// Your extension is activated the very first time the command is executed
export function activate(context: vscode.ExtensionContext) {
	try {
		console.log('üöÄ Todo Task Reminder extension is activating...');
		console.log('üìç Extension path:', context.extensionPath);
		console.log('ÔøΩ Global storage path:', context.globalStorageUri?.fsPath);

		// Create the todo tree data provider
		const todoProvider = new TodoTreeDataProvider(context);
		console.log('‚úÖ TodoTreeDataProvider created successfully');
		
		// Register the tree data provider FIRST
		const treeDataProviderDisposable = vscode.window.registerTreeDataProvider('todoTreeView', todoProvider);
		console.log('‚úÖ Tree data provider registered for todoTreeView');
		context.subscriptions.push(treeDataProviderDisposable);

		// Create tree view with enhanced options
		const treeView = vscode.window.createTreeView('todoTreeView', {
			treeDataProvider: todoProvider,
			canSelectMany: false,
			showCollapseAll: true
		});
		console.log('‚úÖ Tree view created successfully');
		context.subscriptions.push(treeView);

		// Force initial refresh to ensure data is loaded
		setTimeout(() => {
			console.log('üîÑ Triggering initial refresh...');
			todoProvider.refresh();
		}, 100);

	// Register commands
	const commands = [
		// Add Todo Command - Enhanced UX
		vscode.commands.registerCommand('todoManager.addTodo', async () => {
			const result = await showEnhancedTodoCreator();
			if (result) {
				todoProvider.addTodo(result.text, result.priority, result.dueDate, result.projectName);
				
				// Show success with contextual message
				const priorityEmoji = result.priority === 'high' ? 'üî¥' : result.priority === 'medium' ? 'üü°' : 'üü¢';
				const dueDateStr = result.dueDate ? ` (due ${formatDate(result.dueDate)})` : '';
				
				vscode.window.showInformationMessage(
					`‚úÖ ${priorityEmoji} Todo added: "${result.text}"${dueDateStr}`,
					'Add Another',
					'Set Reminder'
				).then(selection => {
					if (selection === 'Add Another') {
						vscode.commands.executeCommand('todoManager.addTodo');
					} else if (selection === 'Set Reminder') {
						// Find the newly added todo and set reminder
						const todos = todoProvider.getTodos();
						const newTodo = todos[todos.length - 1]; // Latest todo
						if (newTodo) {
							const treeItem = new TodoTreeItem(newTodo, vscode.TreeItemCollapsibleState.None);
							vscode.commands.executeCommand('todoManager.setReminder', treeItem);
						}
					}
				});
			}
		}),

		// Delete Todo Command
		vscode.commands.registerCommand('todoManager.deleteTodo', async (item: TodoTreeItem) => {
			if (item) {
				const confirmation = await vscode.window.showWarningMessage(
					`Are you sure you want to delete "${item.todo.text}"?`,
					'Yes', 'No'
				);
				
				if (confirmation === 'Yes') {
					todoProvider.deleteTodo(item.todo.id);
					vscode.window.showInformationMessage('Todo deleted successfully!');
				}
			}
		}),

		// Complete Todo Command
		vscode.commands.registerCommand('todoManager.completeTodo', (item: TodoTreeItem) => {
			if (item) {
				todoProvider.completeTodo(item.todo.id);
				const status = item.todo.completed ? 'marked as pending' : 'completed';
				vscode.window.showInformationMessage(`Todo ${status}!`);
			}
		}),

		// Edit Todo Command - Complete Task Property Editing
		vscode.commands.registerCommand('todoManager.editTodo', async (item: TodoTreeItem) => {
			if (item) {
				const result = await showCompleteTaskEditor(item.todo);
				if (result) {
					// Apply all changes
					todoProvider.updateTodo(item.todo.id, result);
					
					// Show confirmation
					const changes = [];
					if (result.text !== item.todo.text) changes.push('text');
					if (result.priority !== item.todo.priority) changes.push('priority');
					if (result.projectName !== item.todo.projectName) changes.push('project');
					if (result.dueDate?.getTime() !== item.todo.dueDate?.getTime()) changes.push('due date');
					
					const changesList = changes.length > 0 ? changes.join(', ') : 'properties';
					vscode.window.showInformationMessage(`‚úÖ Updated task ${changesList}`);
				}
			}
		}),

		// Set Reminder Command - Enhanced UX
		vscode.commands.registerCommand('todoManager.setReminder', async (item: TodoTreeItem) => {
			if (item) {
				const reminderTime = await showSmartReminderPicker();
				if (reminderTime) {
					todoProvider.setReminder(item.todo.id, reminderTime);
					const timeStr = formatReminderTime(reminderTime);
					vscode.window.showInformationMessage(`‚è∞ Reminder set for ${timeStr}`, 'OK');
				}
			}
		}),

		// Refresh Command
		vscode.commands.registerCommand('todoManager.refreshTodos', () => {
			todoProvider.refresh();
			vscode.window.showInformationMessage('Todos refreshed!');
		}),

		// Open Panel Command
		vscode.commands.registerCommand('todoManager.openPanel', () => {
			vscode.commands.executeCommand('workbench.view.extension.todo-sidebar');
		}),

		// Advanced Grouping Command
		vscode.commands.registerCommand('todoManager.changeGrouping', async () => {
			const groupingOptions = [
				{ label: 'üìÖ Group by Date ‚Üí Status ‚Üí Priority', description: 'Recent tasks first (Recommended)', value: { primary: 'date', secondary: 'status', tertiary: 'priority' } },
				{ label: 'üéØ Group by Status ‚Üí Priority ‚Üí Project', description: 'Focus on task status', value: { primary: 'status', secondary: 'priority', tertiary: 'project' } },
				{ label: '‚≠ê Group by Priority ‚Üí Date ‚Üí Project', description: 'Focus on important tasks', value: { primary: 'priority', secondary: 'date', tertiary: 'project' } },
				{ label: 'üìÅ Group by Project ‚Üí Status ‚Üí Priority', description: 'Focus on projects', value: { primary: 'project', secondary: 'status', tertiary: 'priority' } },
				{ label: 'üìÖ Group by Date Only', description: 'Simple date grouping', value: { primary: 'date' } },
				{ label: 'üéØ Group by Status Only', description: 'Simple status grouping', value: { primary: 'status' } },
				{ label: '‚≠ê Group by Priority Only', description: 'Simple priority grouping', value: { primary: 'priority' } },
				{ label: 'üìÅ Group by Project Only', description: 'Simple project grouping', value: { primary: 'project' } }
			];

			const selected = await vscode.window.showQuickPick(groupingOptions, {
				placeHolder: 'üóÇÔ∏è Choose how to organize your todos',
				matchOnDescription: true,
				ignoreFocusOut: true
			});

			if (selected) {
				todoProvider.setGrouping(selected.value as any);
				vscode.window.showInformationMessage(`üóÇÔ∏è Grouping changed to: ${selected.label.split('‚Üí')[0].trim()}`);
			}
		}),

		// Advanced Filtering Command
		vscode.commands.registerCommand('todoManager.advancedFilter', async () => {
			const filterOptions = [
				{ label: 'üìÖ Today\'s Tasks', description: 'Show only today\'s tasks', value: { dateRange: 'today' } },
				{ label: 'üìÖ This Week', description: 'Show this week\'s tasks', value: { dateRange: 'thisWeek' } },
				{ label: 'üìÖ This Month', description: 'Show this month\'s tasks', value: { dateRange: 'thisMonth' } },
				{ label: '‚ö†Ô∏è Overdue Tasks', description: 'Show only overdue tasks', value: { dateRange: 'overdue' } },
				{ label: 'üî• High Priority Only', description: 'Show only high priority tasks', value: { priority: ['high'] } },
				{ label: 'üìã Pending Tasks Only', description: 'Hide completed tasks', value: { status: ['pending', 'overdue'] } },
				{ label: '‚úÖ Completed Tasks Only', description: 'Show only completed tasks', value: { status: ['completed'] } },
				{ label: 'üîç Custom Filter...', description: 'Build custom filter', value: 'custom' },
				{ label: 'üîÑ Clear All Filters', description: 'Show all tasks', value: 'clear' }
			];

			const selected = await vscode.window.showQuickPick(filterOptions, {
				placeHolder: 'üîç Filter your todos',
				matchOnDescription: true,
				ignoreFocusOut: true
			});

			if (selected) {
				if (selected.value === 'clear') {
					todoProvider.setFilter({ dateRange: 'all' });
					vscode.window.showInformationMessage('üîÑ All filters cleared');
				} else if (selected.value === 'custom') {
					await showCustomFilterBuilder(todoProvider);
				} else {
					todoProvider.setFilter(selected.value as any);
					vscode.window.showInformationMessage(`üîç Filter applied: ${selected.label}`);
				}
			}
		}),

		// Clear Filters Command
		vscode.commands.registerCommand('todoManager.clearFilters', () => {
			todoProvider.setFilter({ dateRange: 'all' });
			vscode.window.showInformationMessage('üîÑ All filters cleared');
		}),

		// Bulk Delete Command
		vscode.commands.registerCommand('todoManager.bulkDelete', async () => {
			const allTodos = todoProvider.getAllTodos();
			if (allTodos.length === 0) {
				vscode.window.showInformationMessage('üì≠ No tasks to delete');
				return;
			}

			// Step 1: Choose deletion scope
			const scopeOptions = [
				{ label: 'üóëÔ∏è Delete Selected Tasks', description: 'Choose specific tasks to delete', value: 'selected' },
				{ label: '‚úÖ Delete All Completed', description: `Delete ${allTodos.filter((t: any) => t.completed).length} completed tasks`, value: 'completed' },
				{ label: '‚ö†Ô∏è Delete All Overdue', description: `Delete ${allTodos.filter((t: any) => t.dueDate && t.dueDate < new Date() && !t.completed).length} overdue tasks`, value: 'overdue' },
				{ label: 'üìÅ Delete by Project', description: 'Delete all tasks from a project', value: 'project' },
				{ label: '‚≠ê Delete by Priority', description: 'Delete all tasks of specific priority', value: 'priority' },
				{ label: 'üóëÔ∏è Delete All Tasks', description: '‚ö†Ô∏è DELETE EVERYTHING', value: 'all' }
			];

			const scopeChoice = await vscode.window.showQuickPick(scopeOptions, {
				placeHolder: 'üóëÔ∏è Choose deletion scope',
				ignoreFocusOut: true
			});

			if (!scopeChoice) return;

			let tasksToDelete: any[] = [];

			switch (scopeChoice.value) {
				case 'selected':
					tasksToDelete = await showTaskSelector(allTodos, 'Delete');
					break;
				case 'completed':
					tasksToDelete = allTodos.filter(t => t.completed);
					break;
				case 'overdue':
					tasksToDelete = allTodos.filter(t => t.dueDate && t.dueDate < new Date() && !t.completed);
					break;
				case 'project':
					tasksToDelete = await selectTasksByProject(allTodos);
					break;
				case 'priority':
					tasksToDelete = await selectTasksByPriority(allTodos);
					break;
				case 'all':
					tasksToDelete = allTodos;
					break;
			}

			if (!tasksToDelete || tasksToDelete.length === 0) {
				vscode.window.showInformationMessage('üì≠ No tasks selected for deletion');
				return;
			}

			// Step 2: Confirmation
			const confirmMessage = `‚ö†Ô∏è Delete ${tasksToDelete.length} task${tasksToDelete.length > 1 ? 's' : ''}?`;
			const confirmOptions = ['Delete', 'Cancel'];
			
			const confirm = await vscode.window.showWarningMessage(
				confirmMessage,
				{ modal: true },
				...confirmOptions
			);

			if (confirm === 'Delete') {
				// Perform bulk deletion
				todoProvider.bulkDeleteTodos(tasksToDelete.map(t => t.id));
				
				vscode.window.showInformationMessage(
					`üóëÔ∏è Successfully deleted ${tasksToDelete.length} task${tasksToDelete.length > 1 ? 's' : ''}`
				);
			}
		}),

		// Quick Filter Commands
		vscode.commands.registerCommand('todoManager.filterToday', () => {
			todoProvider.setFilter({ dateRange: 'today' });
			vscode.window.showInformationMessage('üìÖ Showing today\'s tasks');
		}),

		vscode.commands.registerCommand('todoManager.filterHighPriority', () => {
			todoProvider.setFilter({ priority: ['high'] });
			vscode.window.showInformationMessage('üî• Showing high priority tasks');
		}),

		vscode.commands.registerCommand('todoManager.filterOverdue', () => {
			todoProvider.setFilter({ dateRange: 'overdue' });
			vscode.window.showInformationMessage('‚ö†Ô∏è Showing overdue tasks');
		}),

		// View Task Log Command with Protection
		vscode.commands.registerCommand('todoManager.viewTaskLog', async () => {
			try {
				const path = require('path');
				const os = require('os');
				const fs = require('fs').promises;
				
				const logFilePath = path.join(os.homedir(), 'vscode-todo-tasks.txt');
				
				// Check if file exists and read content
				let logContent = '';
				let fileExists = false;
				
				try {
					logContent = await fs.readFile(logFilePath, 'utf8');
					fileExists = true;
					
					// Check if file is empty or corrupted
					if (!logContent || logContent.trim().length === 0) {
						const choice = await vscode.window.showWarningMessage(
							'üìÑ Task log file is empty. Would you like to regenerate it from current tasks?',
							'Yes, Regenerate',
							'View Empty File',
							'Cancel'
						);
						
						if (choice === 'Yes, Regenerate') {
							const allTodos = todoProvider.getAllTodos();
							logContent = generateLogFromCurrentTasks(allTodos);
						} else if (choice === 'View Empty File') {
							logContent = '# Todo Tasks Log\n# Generated by VS Code Todo Task Reminder Extension\n\n# No tasks found - add some todos to start logging!';
						} else {
							return;
						}
					}
				} catch (error) {
					// If no log file exists, generate one from current tasks
					const allTodos = todoProvider.getAllTodos();
					if (allTodos.length === 0) {
						vscode.window.showInformationMessage(
							'üìÑ No task log found yet. Add some todos to start logging!',
							'Add Todo'
						).then(selection => {
							if (selection === 'Add Todo') {
								vscode.commands.executeCommand('todoManager.addTodo');
							}
						});
						return;
					}
					
					// Generate log content from current tasks
					logContent = generateLogFromCurrentTasks(allTodos);
				}
				
				// Create a read-only document to display log content
				await showProtectedLogView(logContent, logFilePath, todoProvider);
				
			} catch (error) {
				console.error('‚ùå Error opening task log:', error);
				vscode.window.showErrorMessage(`Failed to open task log: ${error}`);
			}
		}),

		// Task Detail View Command with Single Tab Management
		vscode.commands.registerCommand('todoManager.openTaskDetail', async (todo: any) => {
			try {
				const panelKey = `task-${todo.id}`;
				
				// Check if panel for this task already exists
				if (activeTaskDetailPanels.has(panelKey)) {
					const existingPanel = activeTaskDetailPanels.get(panelKey);
					if (existingPanel) {
						// Panel exists, just reveal it and update content
						existingPanel.reveal(vscode.ViewColumn.Beside);
						existingPanel.title = `üìù ${todo.text}`;
						existingPanel.webview.html = generateTaskDetailHTML(todo);
						return;
					}
				}

				// Create a new comprehensive task detail panel
				const panel = vscode.window.createWebviewPanel(
					'taskDetail',
					`üìù ${todo.text}`,
					vscode.ViewColumn.Beside,
					{
						enableScripts: true,
						retainContextWhenHidden: true
					}
				);

				// Store the panel reference
				activeTaskDetailPanels.set(panelKey, panel);

				// Handle panel disposal
				panel.onDidDispose(() => {
					activeTaskDetailPanels.delete(panelKey);
				});

				// Generate the task detail HTML
				panel.webview.html = generateTaskDetailHTML(todo);

				// Handle messages from the webview
				panel.webview.onDidReceiveMessage(async (message) => {
					switch (message.command) {
						case 'complete':
							todoProvider.completeTodo(todo.id);
							// Update the panel content instead of closing
							const updatedTodo = todoProvider.getTodoById(todo.id);
							if (updatedTodo) {
								panel.webview.html = generateTaskDetailHTML(updatedTodo);
							} else {
								panel.dispose(); // Todo was deleted
							}
							break;
						case 'edit':
							// Use the enhanced edit functionality
							vscode.commands.executeCommand('todoManager.editTodo', { todo: todo });
							// Refresh panel content after edit
							setTimeout(() => {
								const updatedTodo = todoProvider.getTodoById(todo.id);
								if (updatedTodo) {
									panel.title = `üìù ${updatedTodo.text}`;
									panel.webview.html = generateTaskDetailHTML(updatedTodo);
								}
							}, 500);
							break;
						case 'delete':
							const confirm = await vscode.window.showWarningMessage(
								'Are you sure you want to delete this task?',
								'Delete', 'Cancel'
							);
							if (confirm === 'Delete') {
								todoProvider.deleteTodo(todo.id);
								panel.dispose();
							}
							break;
						case 'setReminder':
							const reminderResult = await showSmartReminderPicker();
							if (reminderResult) {
								todoProvider.setReminder(todo.id, reminderResult);
								const updatedTodo = todoProvider.getTodoById(todo.id);
								if (updatedTodo) {
									panel.webview.html = generateTaskDetailHTML(updatedTodo);
								}
							}
							break;
						case 'openLog':
							vscode.commands.executeCommand('todoManager.viewTaskLog');
							break;
					}
				});

			} catch (error) {
				console.error('‚ùå Error opening task detail:', error);
				vscode.window.showErrorMessage(`Failed to open task details: ${error}`);
			}
		})
	];

		// Add all commands to subscriptions
		commands.forEach(command => context.subscriptions.push(command));

		// Add tree view to subscriptions
		context.subscriptions.push(treeView);

		// Daily reminder check (runs every hour)
		const reminderInterval = setInterval(() => {
			checkOverdueTodos(todoProvider);
		}, 60 * 60 * 1000); // Check every hour

		context.subscriptions.push({
			dispose: () => clearInterval(reminderInterval)
		});

		console.log('üéâ Todo Task Reminder extension activated successfully!');
		
		// Show success message with better instructions
		vscode.window.showInformationMessage(
			'üéâ Todo Task Reminder activated! Look for the checklist (‚úì) icon in the left Activity Bar.',
			'Open Todo Panel',
			'Show Sample Data'
		).then(selection => {
			if (selection === 'Open Todo Panel') {
				vscode.commands.executeCommand('workbench.view.extension.todo-sidebar');
			} else if (selection === 'Show Sample Data') {
				// Force reveal the view and show sample data
				vscode.commands.executeCommand('workbench.view.extension.todo-sidebar');
				todoProvider.refresh();
			}
		});

	} catch (error) {
		console.error('‚ùå Error activating Todo Task Reminder extension:', error);
		vscode.window.showErrorMessage(`Failed to activate Todo Task Reminder: ${error}`);
	}
}

function checkOverdueTodos(todoProvider: TodoTreeDataProvider) {
	const todos = todoProvider.getTodos();
	const now = new Date();
	
	const overdueTodos = todos.filter(todo => 
		!todo.completed && 
		todo.dueDate && 
		todo.dueDate < now
	);

	if (overdueTodos.length > 0) {
		const message = overdueTodos.length === 1 
			? `You have 1 overdue todo: "${overdueTodos[0].text}"`
			: `You have ${overdueTodos.length} overdue todos`;

		vscode.window.showWarningMessage(
			message,
			'View Todos',
			'Dismiss'
		).then(selection => {
			if (selection === 'View Todos') {
				vscode.commands.executeCommand('workbench.view.extension.todo-sidebar');
			}
		});
	}
}

// This method is called when your extension is deactivated
export function deactivate() {
	// Clean up any active panels
	activeTaskDetailPanels.forEach(panel => {
		if (panel) {
			panel.dispose();
		}
	});
	activeTaskDetailPanels.clear();
}
